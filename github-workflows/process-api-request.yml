# =============================================================================
# apim-apiops-controller: Motor Central de Procesamiento de APIs
# =============================================================================
# Vendor-agnostic: recibe datos de cualquier API Manager (WSO2, Apigee, Kong...)
#
# ESTRUCTURA DE ALMACENAMIENTO:
# apis/
#   {ApiName}/
#     {version}/           <- v1.0.0, v1.1.0, v2.0.0 (max 3 versiones)
#       api.yaml           <- Metadata de la API
#       Definitions/       <- OpenAPI/Swagger
#       Docs/              <- Documentacion
#       revisions/
#         {timestamp}/     <- Cada revision (max 3)
#           request.yaml   <- Metadata del request
#           ... archivos del export
#
# LOGICA:
# 1. Valida subdominio existe
# 2. Busca si API/version existe
# 3. Si existe: crea nueva revision (rotando si hay >3)
# 4. Si no existe: crea version (rotando si hay >3 versiones)
# 5. Ejecuta linters
# 6. Crea CRQ en Helix
# 7. SI Helix APRUEBA -> commit y PR
# =============================================================================
name: Process API Request

on:
  workflow_dispatch:
    inputs:
      subdominio:
        description: 'Subdominio de la API'
        required: true
        type: string
      apiName:
        description: 'Nombre de la API'
        required: true
        type: string
      apiVersion:
        description: 'Version de la API'
        required: true
        type: string
      apiContext:
        description: 'Context path de la API'
        required: false
        type: string
        default: ''
      backendUrl:
        description: 'URL del backend'
        required: false
        type: string
        default: ''
      apiExportZip:
        description: 'ZIP completo del export de apictl (base64)'
        required: true
        type: string
      sourceSystem:
        description: 'Sistema origen (wso2, apigee, kong...)'
        required: false
        type: string
        default: 'wso2'
      userId:
        description: 'Usuario solicitante'
        required: false
        type: string
        default: 'unknown'
      sourceRunUrl:
        description: 'URL del workflow origen'
        required: false
        type: string
        default: ''

env:
  CONFIG_FILE: repo-config.yaml
  MAX_VERSIONS: 3
  MAX_REVISIONS: 3

jobs:
  process-request:
    name: Process API Registration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helix-Processor
        uses: actions/checkout@v4

      - name: Log Request
        run: |
          echo "=========================================="
          echo "  API Registration Request"
          echo "=========================================="
          echo "Subdominio:  ${{ inputs.subdominio }}"
          echo "API:         ${{ inputs.apiName }} v${{ inputs.apiVersion }}"
          echo "Context:     ${{ inputs.apiContext }}"
          echo "Source:      ${{ inputs.sourceSystem }}"
          echo "User:        ${{ inputs.userId }}"
          echo "=========================================="

      - name: Validate Subdominio Exists
        id: validate
        run: |
          SUBDOMINIO="${{ inputs.subdominio }}"

          if ! grep -q "^  ${SUBDOMINIO}:" ${{ env.CONFIG_FILE }}; then
            echo "=========================================="
            echo "  ERROR: Subdominio '$SUBDOMINIO' no existe"
            echo "=========================================="
            echo ""
            echo "Subdominios disponibles:"
            grep -E "^  [a-z]" ${{ env.CONFIG_FILE }} | grep ":" | sed 's/://g' | sed 's/^ */  - /'
            echo ""
            exit 1
          fi

          # Extraer git_repo del subdominio
          GIT_REPO=$(awk "/^  ${SUBDOMINIO}:/{found=1} found && /git_repo:/{print \$2; exit}" ${{ env.CONFIG_FILE }} | tr -d '"')

          if [ -z "$GIT_REPO" ]; then
            echo "ERROR: No se encontro git_repo para subdominio '$SUBDOMINIO'"
            exit 1
          fi

          echo "Subdominio validado: $SUBDOMINIO"
          echo "Target repo: $GIT_REPO"
          echo "git_repo=${GIT_REPO}" >> $GITHUB_OUTPUT

      - name: Decode and Extract API Export
        id: extract
        run: |
          echo "Decoding API export ZIP..."
          mkdir -p ./api-export

          # Decodificar el ZIP
          echo "${{ inputs.apiExportZip }}" | base64 -d > ./api-export/export.zip

          # Descomprimir
          unzip -q ./api-export/export.zip -d ./api-export/extracted

          # Encontrar directorio de la API
          API_DIR=$(find ./api-export/extracted -type d -mindepth 1 -maxdepth 1 | head -1)
          echo "api_dir=${API_DIR}" >> $GITHUB_OUTPUT

          echo "Contenido extraido:"
          ls -la "$API_DIR"

      - name: Check Existing API Structure
        id: check-existing
        env:
          GH_TOKEN: ${{ secrets.SUBDOMINIO_PAT }}
        run: |
          TARGET_REPO="${{ steps.validate.outputs.git_repo }}"
          API_NAME="${{ inputs.apiName }}"
          API_VERSION="${{ inputs.apiVersion }}"

          echo "Checking existing structure for ${API_NAME} v${API_VERSION}..."

          # Clonar repo para analizar estructura
          git clone --depth 1 "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" check-repo 2>/dev/null || true

          API_PATH="check-repo/apis/${API_NAME}"
          VERSION_PATH="${API_PATH}/${API_VERSION}"

          # Variables para tracking
          VERSION_EXISTS="false"
          CURRENT_VERSIONS=0
          CURRENT_REVISIONS=0
          OLDEST_VERSION=""
          OLDEST_REVISION=""

          if [ -d "$API_PATH" ]; then
            echo "API ${API_NAME} ya existe"

            # Contar versiones existentes
            CURRENT_VERSIONS=$(find "$API_PATH" -maxdepth 1 -type d -name "v*" | wc -l | tr -d ' ')
            echo "Versiones actuales: $CURRENT_VERSIONS"

            # Encontrar version mas antigua (por nombre, asumiendo vX.Y.Z)
            if [ "$CURRENT_VERSIONS" -ge "${{ env.MAX_VERSIONS }}" ]; then
              OLDEST_VERSION=$(ls -d ${API_PATH}/v* 2>/dev/null | sort -V | head -1 | xargs basename)
              echo "Version mas antigua: $OLDEST_VERSION"
            fi

            if [ -d "$VERSION_PATH" ]; then
              VERSION_EXISTS="true"
              echo "Version ${API_VERSION} ya existe"

              # Contar revisiones
              if [ -d "${VERSION_PATH}/revisions" ]; then
                CURRENT_REVISIONS=$(find "${VERSION_PATH}/revisions" -maxdepth 1 -type d | tail -n +2 | wc -l | tr -d ' ')
                echo "Revisiones actuales: $CURRENT_REVISIONS"

                # Encontrar revision mas antigua
                if [ "$CURRENT_REVISIONS" -ge "${{ env.MAX_REVISIONS }}" ]; then
                  OLDEST_REVISION=$(ls "${VERSION_PATH}/revisions" 2>/dev/null | sort | head -1)
                  echo "Revision mas antigua: $OLDEST_REVISION"
                fi
              fi
            fi
          else
            echo "API ${API_NAME} es nueva"
          fi

          echo "version_exists=${VERSION_EXISTS}" >> $GITHUB_OUTPUT
          echo "current_versions=${CURRENT_VERSIONS}" >> $GITHUB_OUTPUT
          echo "current_revisions=${CURRENT_REVISIONS}" >> $GITHUB_OUTPUT
          echo "oldest_version=${OLDEST_VERSION}" >> $GITHUB_OUTPUT
          echo "oldest_revision=${OLDEST_REVISION}" >> $GITHUB_OUTPUT

          rm -rf check-repo

      - name: Generate Revision ID
        id: revision-id
        run: |
          REVISION_ID=$(date +%Y%m%d-%H%M%S)
          echo "revision_id=${REVISION_ID}" >> $GITHUB_OUTPUT
          echo "Revision ID: ${REVISION_ID}"

      # =========================================
      # FUTURO: Linters (Spectral, etc.)
      # =========================================
      - name: Run Linters
        run: |
          echo "TODO: Ejecutar linters (Spectral, validaciones de seguridad...)"
          echo "Por ahora: SKIP"

      # =========================================
      # Crear CRQ en Helix - PASO CRITICO
      # Solo si se aprueba se guarda el export
      # =========================================
      - name: Create Helix CRQ
        id: helix
        run: |
          echo "=========================================="
          echo "  Creando CRQ en Helix ITSM"
          echo "=========================================="

          # TODO: Integracion real con Helix API
          # Por ahora simulamos la creacion y aprobacion

          echo "API: ${{ inputs.apiName }} v${{ inputs.apiVersion }}"
          echo "Subdominio: ${{ inputs.subdominio }}"
          echo "Backend: ${{ inputs.backendUrl }}"
          echo "Solicitante: ${{ inputs.userId }}"

          CRQ_ID="CRQ-$(date +%Y%m%d%H%M%S)"
          CRQ_STATUS="APPROVED"

          echo "crq_id=${CRQ_ID}" >> $GITHUB_OUTPUT
          echo "crq_status=${CRQ_STATUS}" >> $GITHUB_OUTPUT

          echo ""
          echo "CRQ creado: ${CRQ_ID}"
          echo "Estado: ${CRQ_STATUS}"

      - name: Check Helix Approval
        id: check-approval
        run: |
          CRQ_STATUS="${{ steps.helix.outputs.crq_status }}"

          if [ "$CRQ_STATUS" != "APPROVED" ]; then
            echo "=========================================="
            echo "  CRQ NO APROBADO - Estado: $CRQ_STATUS"
            echo "=========================================="
            echo "No se guardaran los archivos de la API"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "CRQ APROBADO - Procediendo a guardar archivos"
          echo "approved=true" >> $GITHUB_OUTPUT

      # =========================================
      # SOLO SI HELIX APRUEBA: Guardar en repo subdominio
      # =========================================
      - name: Prepare API Files for Storage
        if: steps.check-approval.outputs.approved == 'true'
        run: |
          API_DIR="${{ steps.extract.outputs.api_dir }}"
          REVISION_ID="${{ steps.revision-id.outputs.revision_id }}"
          mkdir -p "./api-files"

          # Copiar archivos del export
          cp -r "$API_DIR"/* ./api-files/

          # Crear request.yaml con metadata
          cat > ./api-files/request.yaml << EOF
          revision_id: ${REVISION_ID}
          timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          subdominio: ${{ inputs.subdominio }}
          source_system: ${{ inputs.sourceSystem }}
          helix_crq: ${{ steps.helix.outputs.crq_id }}
          helix_status: ${{ steps.helix.outputs.crq_status }}
          api:
            name: ${{ inputs.apiName }}
            version: ${{ inputs.apiVersion }}
            context: ${{ inputs.apiContext }}
            backend_url: ${{ inputs.backendUrl }}
          user: ${{ inputs.userId }}
          source_run: ${{ inputs.sourceRunUrl }}
          processor_run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF

          echo "Archivos preparados:"
          ls -la ./api-files/

      - name: Create PR in Subdominio Repo
        if: steps.check-approval.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.SUBDOMINIO_PAT }}
        run: |
          API_NAME="${{ inputs.apiName }}"
          API_VERSION="${{ inputs.apiVersion }}"
          REVISION_ID="${{ steps.revision-id.outputs.revision_id }}"
          TARGET_REPO="${{ steps.validate.outputs.git_repo }}"
          VERSION_EXISTS="${{ steps.check-existing.outputs.version_exists }}"
          OLDEST_VERSION="${{ steps.check-existing.outputs.oldest_version }}"
          OLDEST_REVISION="${{ steps.check-existing.outputs.oldest_revision }}"
          CURRENT_VERSIONS="${{ steps.check-existing.outputs.current_versions }}"
          CURRENT_REVISIONS="${{ steps.check-existing.outputs.current_revisions }}"
          CRQ_ID="${{ steps.helix.outputs.crq_id }}"

          BRANCH_NAME="api/${API_NAME}-${API_VERSION}-${REVISION_ID}"

          echo "Creating PR in ${TARGET_REPO}"
          echo "API: ${API_NAME} v${API_VERSION}"
          echo "Version exists: ${VERSION_EXISTS}"

          # Clonar repo destino
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" target-repo
          cd target-repo

          # Configurar git
          git config user.name "Helix-Processor Bot"
          git config user.email "helix-processor@github.actions"

          # Crear rama
          git checkout -b "${BRANCH_NAME}"

          # Definir paths
          API_PATH="apis/${API_NAME}"
          VERSION_PATH="${API_PATH}/${API_VERSION}"
          REVISION_PATH="${VERSION_PATH}/revisions/${REVISION_ID}"

          # Crear estructura base
          mkdir -p "${REVISION_PATH}"

          # Si hay demasiadas versiones, eliminar la mas antigua
          ROTATION_MSG=""
          if [ -n "$OLDEST_VERSION" ] && [ "$CURRENT_VERSIONS" -ge "${{ env.MAX_VERSIONS }}" ] && [ "$VERSION_EXISTS" != "true" ]; then
            echo "Eliminando version antigua: ${OLDEST_VERSION}"
            rm -rf "${API_PATH}/${OLDEST_VERSION}"
            ROTATION_MSG="Rotacion: eliminada version ${OLDEST_VERSION}. "
          fi

          # Si hay demasiadas revisiones, eliminar la mas antigua
          if [ -n "$OLDEST_REVISION" ] && [ "$CURRENT_REVISIONS" -ge "${{ env.MAX_REVISIONS }}" ]; then
            echo "Eliminando revision antigua: ${OLDEST_REVISION}"
            rm -rf "${VERSION_PATH}/revisions/${OLDEST_REVISION}"
            ROTATION_MSG="${ROTATION_MSG}Rotacion: eliminada revision ${OLDEST_REVISION}."
          fi

          # Copiar archivos del export a la revision
          cp -r ../api-files/* "${REVISION_PATH}/"

          # Copiar api.yaml y Definitions a la raiz de la version (si existen)
          # para facil acceso
          if [ -f "${REVISION_PATH}/api.yaml" ]; then
            cp "${REVISION_PATH}/api.yaml" "${VERSION_PATH}/"
          fi
          if [ -d "${REVISION_PATH}/Definitions" ]; then
            rm -rf "${VERSION_PATH}/Definitions" 2>/dev/null || true
            cp -r "${REVISION_PATH}/Definitions" "${VERSION_PATH}/"
          fi

          # Commit
          git add .

          if [ "$VERSION_EXISTS" == "true" ]; then
            COMMIT_MSG="feat(${API_NAME}): nueva revision ${REVISION_ID} [${CRQ_ID}]"
          else
            COMMIT_MSG="feat(${API_NAME}): v${API_VERSION} - revision inicial [${CRQ_ID}]"
          fi

          git commit -m "${COMMIT_MSG}"

          # Push
          git push origin "${BRANCH_NAME}"

          # Listar estructura creada
          echo ""
          echo "Estructura creada:"
          find "apis/${API_NAME}" -type f | head -20

          # Determinar titulo del PR
          if [ "$VERSION_EXISTS" == "true" ]; then
            PR_TITLE="UAT [${{ inputs.subdominio }}]: ${API_NAME} v${API_VERSION} - Rev ${REVISION_ID}"
          else
            PR_TITLE="UAT [${{ inputs.subdominio }}]: ${API_NAME} v${API_VERSION}"
          fi

          # Crear PR
          PR_URL=$(gh pr create \
            --repo "${TARGET_REPO}" \
            --base "main" \
            --head "${BRANCH_NAME}" \
            --title "${PR_TITLE}" \
            --body "$(cat <<EOF
          ## API Registration - Helix Approved

          | Campo | Valor |
          |-------|-------|
          | API | ${API_NAME} |
          | Version | ${API_VERSION} |
          | Revision | ${REVISION_ID} |
          | Subdominio | ${{ inputs.subdominio }} |
          | Helix CRQ | ${CRQ_ID} |
          | Estado | APPROVED |
          | Solicitante | ${{ inputs.userId }} |
          | Sistema | ${{ inputs.sourceSystem }} |

          ### Estructura
          \`\`\`
          apis/${API_NAME}/${API_VERSION}/
            api.yaml
            Definitions/
            revisions/${REVISION_ID}/
              request.yaml
              ... archivos del export
          \`\`\`

          ${ROTATION_MSG}

          ### Trazabilidad
          - Source workflow: ${{ inputs.sourceRunUrl }}
          - Processor workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ---
          Aprobado por Helix ITSM - Auto-merged by Helix-Processor
          EOF
          )")

          echo "PR created: ${PR_URL}"

          # Auto-merge
          gh pr merge "${BRANCH_NAME}" --repo "${TARGET_REPO}" --auto --squash || echo "Auto-merge no disponible, PR queda abierta"

          echo ""
          echo "=========================================="
          echo "  SUCCESS!"
          echo "  PR: ${PR_URL}"
          echo "  API: ${API_NAME} v${API_VERSION}"
          echo "  Revision: ${REVISION_ID}"
          echo "  CRQ: ${CRQ_ID}"
          echo "=========================================="

      - name: Summary
        run: |
          echo "## API Processing Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ inputs.apiName }} v${{ inputs.apiVersion }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Subdominio | ${{ inputs.subdominio }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Revision | ${{ steps.revision-id.outputs.revision_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Helix CRQ | ${{ steps.helix.outputs.crq_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Estado | ${{ steps.helix.outputs.crq_status }} |" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check-approval.outputs.approved }}" == "true" ]; then
            echo "| Target Repo | ${{ steps.validate.outputs.git_repo }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Estructura | apis/${{ inputs.apiName }}/${{ inputs.apiVersion }}/ |" >> $GITHUB_STEP_SUMMARY
            echo "| Archivos | Guardados |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Archivos | No guardados (CRQ no aprobado) |" >> $GITHUB_STEP_SUMMARY
          fi
